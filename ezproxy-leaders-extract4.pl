use strict;
use warnings;
use v5.8;
 
my $filename = 'ezp202005.log'; # вход€щий файл лога, открываем
open(my $fh, '<:encoding(UTF-8)', $filename)
  or die "Could not open file '$filename' $!";

# дата дл€ извлечени€ из файла лога инфы только за определенную дату
my $strdate=q|10\/May\/2020|;

# шаблон дл€ парсинга строк лога
# где:
#   $1 -- IP-адрес
#   $2 -- какой-то хеш, наверно дл€ ID сессии
#   $3 -- врем€ (без даты)
#   $4 -- размер отданных клиенту данных, байт
my $pattern  = q|^([0-9]{1,3}[\.][0-9]{1,3}[\.][0-9]{1,3}[\.][0-9]{1,3})\s+-\s+([a-zA-Z0-9]{15})\s+\[|.$strdate.q|\:([0-9]{2}\:[0-9]{2}\:[0-9]{2})\s{1}\+[0-9]{4}\]\s+|;
$pattern .= q|["][^"]+["]\s+\d{1,3}\s+([0-9]+).*$|;

# ассоциативный массив (хеш) дл€ хранени€ отчета, ключ -- IP-адрес, значение -- суммарный трафик за календарные сутки
my %hosts1 = ();

# читаем входной файл построчно
while (my $row = <$fh>) {
  chomp $row;

# если строка удовлетвор€ет регул€рному выражению, извлекаем данные и записываем их в ассоциативный массив (хеш)
if (my @strm = $row =~ m/$pattern/) { $hosts1{$1} += $4; }

}

# выводим результат в STDOUT (но можно перенаправить вывод в .csv-файл, правильно?)
# шапка csv
#   комментарий с датой отчета
printf "# DATE IS %s\n",$strdate;
#   шапка таблицы
printf "IP,SIZE\n";
# сортируем строки хеша по убыванию значений (лидеры по скачиванию будут наверху)
for my $key (sort { $hosts1{$b} <=> $hosts1{$a} } keys %hosts1) {
# выводим
  printf "%s,%s\n",$key,${hosts1}{$key};
}
